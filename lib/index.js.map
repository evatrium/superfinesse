{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["const RECYCLED_NODE = 1,\n    TEXT_NODE = 3,\n    EMPTY_OBJ = {},\n    EMPTY_ARR = [],\n    map = EMPTY_ARR.map,\n    IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i,\n    isArray = Array.isArray,\n    d = document,\n\n    eventProxy = function (e) {\n        return this.__ev[e.type](e);\n    },\n\n    setStyle = (style, key, value) => {\n        if (key[0] === '-') style.setProperty(key, value);\n        else style[key] = typeof value === 'number'\n        && IS_NON_DIMENSIONAL.test(key) === false ? value + 'px' : value == null ? '' : value;\n    },\n    // preact inspired setProperty\n    setProperty = (dom, name, value, oldValue, isSvg, _style, _newHTML) => {\n        if (isSvg) {\n            if (name === 'className') name = 'class';\n        } else if (name === 'class') name = 'className';\n        if (name === 'key' || name === 'children') {\n        } else if (name === 'style') {\n            _style = dom.style;\n            if (typeof value === 'string') _style.cssText = value;\n            else {\n                if (typeof oldValue === 'string') (_style.cssText = '', oldValue = null);\n                if (oldValue) for (let i in oldValue) if (!(value && i in value)) setStyle(_style, i, '');\n                if (value) for (let i in value) if (!oldValue || value[i] !== oldValue[i]) setStyle(_style, i, value[i]);\n            }\n        } else if (name[0] === 'o' && name[1] === 'n') {\n            let useCapture = name !== (name = name.replace(/Capture$/, '')),\n                nameLower = name.toLowerCase();\n            name = (nameLower in dom ? nameLower : name).slice(2);\n            if (value) {\n                if (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n                (dom.__ev || (dom.__ev = {}))[name] = value;\n            } else dom.removeEventListener(name, eventProxy, useCapture);\n        } else if (name === 'dangerouslySetInnerHTML') {\n            if (value || oldValue) {\n                if (!value || !oldValue || value.__html != oldValue.__html) {\n                    dom.innerHTML = (value && value.__html) || '';\n                }\n                if (value) return true\n            }\n        } else if (!(['list', 'tagName', 'form', 'type', 'size'].includes(name)) && !isSvg && name in dom) {\n            dom[name] = value == null ? '' : value;\n        } else if (typeof value !== 'function') {\n            if (name !== (name = name.replace(/^xlink:?/, ''))) {\n                if (value == null || value === false) {\n                    dom.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());\n                } else dom.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);\n            } else if (value == null || (value === false && !/^ar/.test(name))) dom.removeAttribute(name);\n            else dom.setAttribute(name, value);\n        }\n    },\n\n    diffProps = (dom, newProps, oldProps, isSvg, _skipDiffChildren) => {\n        let i;\n        for (i in oldProps) if (!(i in newProps)) {\n            if (setProperty(dom, i, null, oldProps[i], isSvg)) _skipDiffChildren = true;\n        }\n        for (i in newProps) if (i !== 'value' && i !== 'checked' && oldProps[i] !== newProps[i]) {\n            if (setProperty(dom, i, newProps[i], oldProps[i], isSvg)) _skipDiffChildren = true;\n        }\n        return _skipDiffChildren\n    },\n\n    getKey = (vnode) => vnode == null ? null : vnode.key,\n\n    patchNode = (parent, node, oldVNode, newVNode, isSvg) => {\n        if (oldVNode === newVNode) {\n        } else if (\n            oldVNode != null &&\n            oldVNode.type === TEXT_NODE &&\n            newVNode.type === TEXT_NODE\n        ) {\n            if (oldVNode.name !== newVNode.name) node.nodeValue = newVNode.name\n        } else if (oldVNode == null || oldVNode.name !== newVNode.name) {\n            node = parent.insertBefore(createNode(newVNode, isSvg), node)\n            if (oldVNode != null) {\n                parent.removeChild(oldVNode.node)\n            }\n        } else {\n            let tmpVKid, oldVKid,\n                oldKey, newKey,\n                oldVProps = oldVNode.props,\n                newVProps = newVNode.props,\n                oldVKids = oldVNode.children,\n                newVKids = newVNode.children,\n                oldHead = 0,\n                newHead = 0,\n                oldTail = oldVKids.length - 1,\n                newTail = newVKids.length - 1;\n\n            isSvg = isSvg || newVNode.name === \"svg\"\n\n            if (diffProps(node, newVProps, oldVProps, isSvg)) {\n                return (newVNode.node = node);\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldHead])) == null ||\n                    oldKey !== getKey(newVKids[newHead])\n                ) {\n                    break\n                }\n                patchNode(\n                    node,\n                    oldVKids[oldHead].node,\n                    oldVKids[oldHead++],\n                    newVKids[newHead++],\n                    isSvg\n                )\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldTail])) == null ||\n                    oldKey !== getKey(newVKids[newTail])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldTail].node,\n                    oldVKids[oldTail--],\n                    newVKids[newTail--],\n                    isSvg\n                )\n            }\n\n            if (oldHead > oldTail) {\n                while (newHead <= newTail) {\n                    node.insertBefore(\n                        createNode(newVKids[newHead++], isSvg),\n                        (oldVKid = oldVKids[oldHead]) && oldVKid.node\n                    )\n                }\n            } else if (newHead > newTail) {\n                while (oldHead <= oldTail) {\n                    node.removeChild(oldVKids[oldHead++].node)\n                }\n            } else {\n                for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n                    if ((oldKey = oldVKids[i].key) != null) {\n                        keyed[oldKey] = oldVKids[i]\n                    }\n                }\n\n                while (newHead <= newTail) {\n                    oldKey = getKey((oldVKid = oldVKids[oldHead]))\n                    newKey = getKey(newVKids[newHead])\n\n                    if (\n                        newKeyed[oldKey] ||\n                        (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n                    ) {\n                        if (oldKey == null) {\n                            node.removeChild(oldVKid.node)\n                        }\n                        oldHead++\n                        continue\n                    }\n\n                    if (newKey == null || oldVNode.type === RECYCLED_NODE) {\n                        if (oldKey == null) {\n                            patchNode(\n                                node,\n                                oldVKid && oldVKid.node,\n                                oldVKid,\n                                newVKids[newHead],\n                                isSvg\n                            )\n                            newHead++\n                        }\n                        oldHead++\n                    } else {\n                        if (oldKey === newKey) {\n                            patchNode(node, oldVKid.node, oldVKid, newVKids[newHead], isSvg)\n                            newKeyed[newKey] = true\n                            oldHead++\n                        } else {\n                            if ((tmpVKid = keyed[newKey]) != null) {\n                                patchNode(\n                                    node,\n                                    node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                                    tmpVKid,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                                newKeyed[newKey] = true\n                            } else {\n                                patchNode(\n                                    node,\n                                    oldVKid && oldVKid.node,\n                                    null,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                            }\n                        }\n                        newHead++\n                    }\n                }\n\n                while (oldHead <= oldTail) {\n                    if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n                        node.removeChild(oldVKid.node)\n                    }\n                }\n\n                for (var i in keyed) {\n                    if (newKeyed[i] == null) {\n                        node.removeChild(keyed[i].node)\n                    }\n                }\n            }\n        }\n\n        return (newVNode.node = node)\n    },\n\n    createNode = (vnode, isSvg) => {\n        var node = vnode.type === TEXT_NODE\n            ? d.createTextNode(vnode.name)\n            : (isSvg = isSvg || vnode.name === \"svg\")\n                ? d.createElementNS(\"http://www.w3.org/2000/svg\", vnode.name)\n                : d.createElement(vnode.name);\n        diffProps(node, vnode.props, {}, isSvg);\n        for (var i = 0, len = vnode.children.length; i < len; i++) {\n            node.appendChild(createNode(vnode.children[i], isSvg))\n        }\n        return (vnode.node = node)\n    },\n\n    createVNode = (name, props, children, node, key, type) => ({\n        name: name,\n        props: props,\n        children: children,\n        node: node,\n        type: type,\n        key: key,\n    }),\n\n    createTextVNode = (value, node) => createVNode(value, EMPTY_OBJ, EMPTY_ARR, node, null, TEXT_NODE),\n\n    recycleNode = (node, parent) => {\n        return node.nodeType === TEXT_NODE\n            ? createTextVNode(node.nodeValue, node)\n            : createVNode(\n                node.nodeName.toLowerCase(),\n                EMPTY_OBJ,\n                map.call(node.childNodes, recycleNode),\n                node,\n                null,\n                RECYCLED_NODE\n            )\n    },\n\n    Fragment = (props) => props.children,\n\n    render = (vdom, node, options) => {\n        let oldVDom = node.vdom || recycleNode(node);\n\n        vdom = createVNode(// this enables the use of a root fragment\n            oldVDom.name,\n            EMPTY_OBJ,\n            [].concat(vdom),\n            oldVDom.node\n        );\n        return ((node = patchNode(\n            node.parentNode,\n            node,\n            oldVDom,\n            vdom\n        )).vdom = vdom), node\n    },\n\n    mount = (vdom, node) => {\n        if (!isArray(vdom)) vdom = [vdom];\n        for (var i = vdom.length; i--;) node.insertBefore(createNode(vdom[i]), node.firstChild)\n    },\n\n    h = function (name, props) {\n        for (var vnode, rest = [], children = [], i = arguments.length; i-- > 2;) rest.push(arguments[i]);\n        if ((props = props == null ? {} : props).children != null) {\n            if (rest.length <= 0) rest.push(props.children);\n            delete props.children;\n        }\n        while (rest.length > 0) {\n            if (isArray((vnode = rest.pop()))) {\n                for (var i = vnode.length; i-- > 0;) rest.push(vnode[i])\n            } else if (vnode === false || vnode === true || vnode == null) {\n            } else children.push(typeof vnode === 'object' ? vnode : createTextVNode(vnode));\n        }\n        return typeof name === 'function'\n            ? (props.children = props.children || children) && name(props)\n            : createVNode(name, props, children, null, props.key)\n    };\n\nexport {h, render, Fragment, createNode, mount};"],"names":["RECYCLED_NODE","EMPTY_OBJ","EMPTY_ARR","map","IS_NON_DIMENSIONAL","isArray","Array","d","document","eventProxy","e","__ev","type","setStyle","style","key","value","setProperty","test","dom","name","oldValue","isSvg","_style","_newHTML","cssText","i","useCapture","replace","nameLower","toLowerCase","slice","addEventListener","removeEventListener","__html","innerHTML","includes","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","diffProps","newProps","oldProps","_skipDiffChildren","getKey","vnode","patchNode","parent","node","oldVNode","newVNode","nodeValue","insertBefore","createNode","removeChild","tmpVKid","oldVKid","oldKey","newKey","oldVKids","children","newVKids","oldHead","newHead","oldTail","length","newTail","props","keyed","newKeyed","createTextNode","createElementNS","createElement","len","appendChild","createVNode","createTextVNode","recycleNode","nodeType","nodeName","call","childNodes","Fragment","render","vdom","options","oldVDom","concat","parentNode","mount","firstChild","h","rest","arguments","push","pop"],"mappings":"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"}